# 函数抽象原则与方法



几乎所有讲述`重构`、`提高代码质量`的书籍中都会提到函数抽象（或函数提取）这一原则。大部分的书籍都会推荐开发者减少函数体的代码量，尽量将函数的行数控制在30行以内（有的要求的甚至更严苛），减少代码量是毋庸置疑的事情，我相信没有一个开发者会反对这件事情。但是本文所要描述的并不是如何减少函数的代码量，而是着重于如何去除重复代码，在了解这些知识点前，请务必达到以下共识：

**代码是写给人看的而非机器，可读性是编码的第一原则（可执行是第零原则）。**

## 我们的代码是如何重复的？
**代码空间隔离**。这个问题的答案特别简单，因为我们的代码空间被隔离了，所以造成了代码重复的情况。举个例子（Java）：
A是某功能的作者，有一天其接到一个需求，该功能需要获取本周开始到结束的7天的时间列表，于是A在功能的某个类中使用一个私有方法实现了这一功能：

```java
private List<Date> getDatesInWeek() {
    // ... 
}
```
过两天，A维护的另一个功能也需要这样的操作，于是A将上述的私有方法复制到了新的类中。

这就是一个很简单的代码重复的场景。

## 如何解决代码的重复？
重复代码的消除从来都不是什么难题，难的是改变编码人的思维模式。开发者应当清楚的是：
**当一段代码在不同的地方被多次书写时，必然会造成维护上的巨大困难，甚至有可能产生生产事故。**
这么说并不是空穴来风，我们还是以上述的例子来讲解，为什么重复的代码可能造成极其严重的线上事故：

假设现在假设A已离职，留下B来维护原来的功能。此时需求发生了变更，获取本周开始到结束的时间列表需要去除周末两天，只保留工作日。由于业务的不熟悉，B只修改了其中的一个私有方法，另一个类的方法没有对应改动（其实也适应新的需求）。修改完后，新代码匆匆上线，很多用户发现在多处出现了不一样的表现，于是，一次线上事故就发生了...

如果A承认并遵守我们所提到的**不允许同样的代码出现在不同的位置**这一原则，错误就不会层层传递，直到用户发现bug。在最初实现时，A应当设法去消除这两个重复的私有方法，取而代之使用工具类的通用函数来实现：
```java
// DateUtils.java

public static List<Date> getDatesInWeek() {
    // ...
}
```
当需求变更后，也无需重新添加新的工具函数，而是为原有的函数添加参数来实现：
```java
// onlyWorkDay表示是否只返回工作日列表
public static List<Date> getDatesInWeek(boolean onlyWorkDay) {
    // ...
}
```
如果A是更有经验的开发者，Ta会想的更加深远，未来是否有可能获取过去或未来的周的日期列表呢？于是让该函数变得更加抽象：
```java
// 传递day参数表示日期所在周，不传递该参数表示本周
public static List<Date> getDatesInWeek(Date day, boolean onlyWorkDay) {
    // ...
}

```

## 更多实践
需要注意的是，抽象思想与具体使用的语言类型、语言环境、运行机制是无关的，无论是c这种面向过程的语言，还是Java、C#这种面向对象的语言，亦或是JavaScript这种异步的函数式编程语言，你都可以对冗长的代码进行抽象。相对于面向对象语言而言，你可以选择使用继承、组合的方式实现更复杂的抽象，而不是简单的函数提取。

在JavaScript中，很多人会面临这样的场景：代码是异步执行的，如何抽象呢？请看下方代码：
```js
function submit() {
    $.ajax({
        url: 'getDatesInWeek',
        success: function(result) {
            if (result.success) {
                alert('获取成功')
            } else {
                alert('获取失败：' + result.msg)
                // 操作1
                // 操作2
            }
        },
        error: function(e) {
            alert('获取失败：' + e.message)
            // 操作1
            // 操作2
        }
    })
}
```
很显然，不管是请求成功后返回错误码还是网络错误导致的请求失败，实际都算请求最终失败了，在上述的代码中，对于失败的情况实际上执行了两遍相同的代码，这种情况违背我们**同一段代码不能出现在多处**的原则，于是我们做出如下的抽象：
```js
function submit() {
    $.ajax({
        url: 'getDatesInWeek',
        success: function(result) {
            if (result.success) {
                alert('获取成功')
            } else {
                doError(result.msg)
            }
        },
        error: function(e) {
            doError(e.message)
        }
    })
    
    function doError(msg) {
        alert('获取失败：' + msg)
        // 操作1
        // 操作2
    }
}
```
JavaScript的闭包恰好成了我们解决重复代码的利器，也再次论证了我们的观点，只要有语言存在的地方，抽象一定存在。