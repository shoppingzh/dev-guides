### 用户体验
- 操作成功的提示信息可以加感叹号，如**恭喜您，购买成功！**，操作失败的提示信息尽量不要加感叹号，以防给用户压迫感，可以使用**操作失败，请稍后重试。**等较为温和的提示信息。

- 【推荐】除非必要，不要使用遮罩层锁屏或弹出内容打断用户操作，除了如删除前确认提示等必要的情况之外尽量不要打扰到用户。

**最佳实践：** 如何处理保存时的提示操作？ 推荐的做法是禁用按钮，在按钮上添加提示图标和信息，在请求结束后再将按钮复原到原有样式。



### JS篇
- 【强制】无论在什么情况下都要注意undefined，规避undefined有很多方式，以下提供一种好用简单的方法：
```javascript
    // 参数arg需要传入字符串
    function func(arg){
        //
    }
    
    var val; // undefined
    func(val || ''); // 最终传入函数的参数为空字符串，而非undefined
```

- 【实践】js中undefined/null/""的区别：
undefined才是js真正处理为空的标准，null只是针对对象(Object)而言，如：
```javascript
function getObject(flag){
    if(flag){
        return {
            name: '二蛋',
            age: 12
        };
    }
    // 之所以返回null是因为此函数约定输出一个对象，如果为空，就应该输出对象的空值null，而为不输出，不输出就是undefined
    return null;
}
```
如果要判断一个字符串不为空，不懂这三者区别的童鞋可能会这样判断：
```javascript
if(str != undefined && str != null && str != ""){}
```
但是，实际上只要这样判断就可以了：
```javascript
if(str){}
```

- 【实践】js判空，以下演示两种经典的判空场景：
```javascript
    var str = '123';
    if(str){} // str != undefined && str不为空
    var arr = [];
    if(arr && arr.length){} // arr != undefined && 数组不为空
```
**js将undefined/null/空字符串/0转换为布尔值false**


### BUI篇
- 【强制】后台不允许传递诸如 `pages/page/module1/index.html` 这样的路由地址到前台，如果前台更改了此路由地址对应的文件名或路径将导致路由失败。
  *如果路由的地址在特定情况下会发生变化，则传递一个标志该变化的参数到前台，有前台决定路由到什么地址*

- 【强制】BUI的所有图标均以"icon-"开头，如果我们需要定义自己的图标，切勿以"icon-"开头，应当与BUI的图标区分开。
  正例：icons-home icons-user
  反例：icon-home icon-user

- 【强制】选取元素一律使用router.$('#id')的方式，不要使用$('#id')这种方式获取，router.$()方式能保证获取到的元素是该模块下的，而$()不能，在某些特殊情况下可能会获取到多个相同id的元素，因此，在不知道用什么方法时使用最稳妥的router.$()方法。

- 【强制】不要修改header/main/footer标签的样式。单页应用通过js将内容渲染到页面，其本质是dom元素的替换，在页面切换时，BUI会动态地替换main标签中的内容，如果给main添加了样式例如一个背景色将会导致在下一个页面也被应用上。
  正确做法：假如要给main提供一个背景色，请在main下定义一个div使该div的高度为100%，然后将该div的背景色替换掉即可，其它样式同理。

- 【推荐】使用BUI提供的布局框架。BUI提供的布局是以flex布局为基础。

- 【强制】表单校验失败时的提示一律使用hint组件，不要使用alert组件，对用户而言肯定不希望每次一点提交就弹出了令人反感的提示框，使用hint组件在上方弹出错误原因可以有效降低打扰率，提高用户的效率。

**最佳实践：**上述方式也不是最佳方案，因为表单的错误没有一次性暴露出来，最好的方法是在表单的控件周围显示错误信息以告知用户。

- 【强制】针对BUI的单页开发，无论在任何情况下都不要使用诸如`location.reload()`等方式刷新页面，单页开发的意义在于页面只会在初始化的时候发生一次同步请求，之后的所有页面都使用异步的方式渲染到客户端，如果使用同步刷新的方式就是违背了单页开发的本质。

- 【重要】BUI的loadPart方法是有一定的问题的，父级页面在loadPart子页面后，父级页面的router.$()将取不到任何元素。此问题已经反馈给BUI的作者，将在下个版本（当前版本1.5.3）进行修复。


### art-tempalte篇
- template id的问题
template()函数的第一个参数为容器的id，这个id在全局必须是唯一的，否则只会取所有元素的第一个。


